# PP-2
Лабораторная работа №1 по параллельному программированию. Выполнила Карпачева Полина Олеговна, гр. 6312-100503D

Задание: Модифицировать программу из л/р №1 для параллельной работы по технологии OpenMP.

Объемы задачи: матрицы 500х500, 1000х1000, 1500х1500;

OpenMP (Open Multi-Processing) - это набор директив, функций и переменных среды для параллельного программирования на языках C, C++ и Fortran. OpenMP предоставляет простой и эффективный способ создания параллельных программ, используя многопоточность.

Основные особенности OpenMP:

+ Директивы: OpenMP использует специальные директивы, которые встраиваются в исходный код программы и указывают компилятору, какие участки кода должны выполняться параллельно.+
+ Распараллеливание циклов: Одной из ключевых возможностей OpenMP является автоматическое распараллеливание циклов. Это позволяет легко распараллеливать циклы и ускорять выполнение программ.
+ Работа с потоками: OpenMP позволяет создавать и управлять потоками исполнения в рамках параллельных участков кода.
+ Синхронизация: OpenMP предоставляет механизмы для синхронизации потоков, такие как критические секции, блокировки, атомарные операции и т.д.
+ Поддержка различных платформ: OpenMP поддерживается на многих платформах и компиляторах, что делает его широко используемым инструментом для параллельного программирования.

Использование OpenMP позволяет эффективно использовать многоядерные процессоры и ускорить выполнение вычислительно интенсивных задач.

С помощью стандарта OpenMP (Open Multi-Processing) было реализовано распараллеливание функции умножения матриц

```
int** MultiplyMatrix(int** matrix, int rows) {
    int i, j, k;
    int** matrix_new = new int* [rows];
    for (int i = 0; i < rows; i++) {
        matrix_new[i] = new int[rows];
    }

#pragma omp parallel for shared(matrix, matrix_new) private(i, j, k)
    for (i = 0; i < rows; i++) {
        for (j = 0; j < rows; j++) {
            int sum = 0;
            for (k = 0; k < rows; k++) {
                sum += (matrix[i][k] * matrix[k][j]);
            }
            matrix_new[i][j] = sum;
        }
    }

    return matrix_new;
}
```

## int** MultiplyMatrix(int** matrix, int rows)
Функция принимает два входных параметра:
matrix: указатель на двумерный массив целых чисел, представляющий входную матрицу.
rows: целое число, представляющее количество строк (и столбцов) во входной матрице.
Функция возвращает указатель на двумерный массив целых чисел, представляющий результат умножения входной матрицы на себя.
Выделение памяти

Функция выделяет память для новой двумерной матрицы matrix_new с таким же количеством строк и столбцов, как и у входной матрицы.

### Параллелизация

Функция использует OpenMP для параллелизации умножения матриц. Директива #pragma omp parallel for сообщает компилятору параллелизировать следующий цикл for.

### Умножение матриц

Функция выполняет умножение матриц с помощью трех вложенных циклов:

+ Внешний цикл перебирает строки входной матрицы (i).
+ Средний цикл перебирает столбцы входной матрицы (j).
+ Внутренний цикл вычисляет скалярное произведение i-й строки и j-го столбца входной матрицы (k).
+ Скалярное произведение вычисляется как sum += (matrix[i][k] * matrix[k][j]), и результат сохраняется в matrix_new[i][j].

### Возврат значения

Функция возвращает указатель на результирующую матрицу matrix_new.

## Вывод

При проведении эксперимента с умножением матриц на процессоре AMD RYZEN 5 с 4 ядрами было выявлено, что использование 2 потоков привело к значительному снижению времени выполнения операции с 7 до 5 минут. Однако, при увеличении количества потоков до 8 и 16, время работы программы резко увеличилось из-за ограниченного количества физических ядер процессора. Исходя из этого, можно сделать вывод, что оптимальным выбором для данного процессора является использование 2,4 потоков для выполнения операции умножения матриц.

Из анализа статистики эксперимента видно, что использование стандарта OpenMP позволило значительно ускорить операцию умножения матриц различных размеров (500х500, 1000х1000, 1500х1500). Разделение работы между потоками позволило эффективнее использовать вычислительные ресурсы процессора и снизить общее время выполнения операции. Таким образом, использование OpenMP в данном случае действительно привело к повышению производительности и оптимизации выполнения задачи умножения матриц.
